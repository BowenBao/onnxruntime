syntax = "proto2";

package CommonIR;


// Defines the type system.
// NOTE: As a minimal requirement, a framework must support tensor type.
message TypeProto {
  // The basic data type.
  enum DataType {
    UNDEFINED = 0;

    // Basic types.
    FLOAT = 1;  // float
    DOUBLE = 2; // double
    UINT8 = 3;  // uint8_t
    INT8 = 4;  // int8_t
    UINT16 = 5;  // uint16_t
    INT16 = 6; // int16_t
    INT32 = 7;  // int32_t
    INT64 = 8;  // int64_t
    STRING = 9;  // string
    BOOL = 10;  // bool

    // Advanced types
    FLOAT16 = 11;
    COMPLEX64 = 12;  // single precision complex, 32-bit real and imaginary components
    COMPLEX128 = 13;  // double precision complex, 64-bit real and imaginary components

    // TBD: More types to be added.
  };

  message TensorTypeProto {
    optional DataType elem_type = 1;
  }

  message SparseTensorTypeProto {
    optional DataType elem_type = 1;
  }

  message HandleTypeProto {
  };

  message TupleTypeProto {
    repeated TypeProto elem_type = 1;
  };

  message SeqTypeProto {
    optional TypeProto elem_type = 1;
  };

  oneof value {
    // The type of a tensor.
    TensorTypeProto tensor_type = 1;

    // The type of a sparse tensor.
    SparseTensorTypeProto sparse_tensor_type = 2;

    // The type of a completely opaque handle. A handle typically represents
    // a reference to a resource managed by the framework runtime.
    HandleTypeProto handle_type = 3;

    // The type of a tuple.
    TupleTypeProto tuple_type = 4;

    // The type of a sequence.
    SeqTypeProto seq_type = 5;
  }
};